--- opennurbs/opennurbs_x.cpp	1969-12-31 19:00:00.000000000 -0500
+++ openNURBS/opennurbs_x.cpp	2023-09-09 13:43:33.728976149 -0400
@@ -0,0 +1,1024 @@
+/* $NoKeywords: $ */
+/*
+//
+// Copyright (c) 1993-2007 Robert McNeel & Associates. All rights reserved.
+// Rhinoceros is a registered trademark of Robert McNeel & Assoicates.
+//
+// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
+// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
+// MERCHANTABILITY ARE HEREBY DISCLAIMED.
+//				
+// For complete openNURBS copyright information see <http://www.opennurbs.org>.
+//
+////////////////////////////////////////////////////////////////
+*/
+
+#include "opennurbs.h"
+
+ON_X_EVENT::ON_X_EVENT()
+{
+  memset(this,0,sizeof(*this));
+}
+
+int ON_X_EVENT::Compare( const ON_X_EVENT* a, const ON_X_EVENT* b) 
+{
+  if ( !a )
+  {
+    return b ? 1 : 0;
+  }
+
+  if  (!b)
+    return -1;
+
+	if( a->m_a[0] < b->m_a[0])
+		return -1;
+	
+  if( a->m_a[0] > b->m_a[0])
+		return 1;
+
+	if( a->m_a[1] < b->m_a[1])
+		return -1;
+	
+  if( a->m_a[1] > b->m_a[1])
+		return 1;
+
+	return 0;
+}
+
+static void DumpDistanceABHelper( ON_TextLog& text_log, ON_3dPoint A, ON_3dPoint B )
+{
+  const double tinyd = 1.0e-14;
+  double d = A.DistanceTo(B);
+  text_log.Print("distance A to B");
+  if ( !ON_IsValid(d) || d >= 1.0e-14 || d <= 0.0 )
+  {
+    text_log.Print(" = ");
+  }
+  else
+  {
+    // This prevents diff from compaining about tiny changes.
+    text_log.Print(" < ");
+    d = tinyd;
+  }
+  text_log.Print(d);
+  text_log.Print("\n");
+}
+
+static void DumpDistanceABHelper( ON_TextLog& text_log, ON_3dPoint A0, ON_3dPoint B0, ON_3dPoint A1, ON_3dPoint B1 )
+{
+  if ( A0.DistanceTo(B0) <= A1.DistanceTo(B0) )
+    DumpDistanceABHelper( text_log, A0, B0 );
+  else
+    DumpDistanceABHelper( text_log, A1, B1 );
+}
+
+void ON_X_EVENT::Dump(ON_TextLog& text_log) const
+{
+  int j;
+
+  text_log.Print("m_type: ");
+  switch( m_type )
+  {
+  case ON_X_EVENT::no_x_event:
+    text_log.Print("no_x_event");
+    break;
+  case ON_X_EVENT::ccx_point:
+    text_log.Print("ccx_point");
+    break;
+  case ON_X_EVENT::ccx_overlap:
+    text_log.Print("ccx_overlap");
+    break;
+  case ON_X_EVENT::csx_point:
+    text_log.Print("csx_point");
+    break;
+  case ON_X_EVENT::csx_overlap:
+    text_log.Print("csx_overlap");
+    break;
+  default:
+    text_log.Print("illegal value");
+    break;
+  }
+  text_log.Print("\n");
+  text_log.PushIndent();
+
+  switch( m_type )
+  {
+  case ON_X_EVENT::ccx_point:
+  case ON_X_EVENT::csx_point:
+    // don't use %g so the text_log double format can control display precision
+    text_log.Print("curveA(");
+    text_log.Print(m_a[0]);
+    text_log.Print(") = \n");
+    text_log.PushIndent();
+    text_log.Print(m_A[0]);
+    text_log.Print("\n");
+    text_log.PopIndent();
+    break;
+
+  case ON_X_EVENT::ccx_overlap:
+  case ON_X_EVENT::csx_overlap:
+    // don't use %g so the text_log double format can control display precision
+    text_log.Print("curveA(");
+    text_log.Print(m_a[0]);
+    text_log.Print(" to ");
+    text_log.Print(m_a[1]);
+    text_log.Print(") = \n");
+    text_log.PushIndent();
+    text_log.Print(m_A[0]);
+    text_log.Print(" to ");
+    text_log.Print(m_A[1]);
+    text_log.Print("\n");
+    text_log.PopIndent();
+    break;
+
+  case ON_X_EVENT::no_x_event:
+    break;
+  }
+
+  switch( m_type )
+  {
+  case ON_X_EVENT::ccx_point:
+    // don't use %g so the text_log double format can control display precision
+    text_log.Print("curveB(");
+    text_log.Print(m_b[0]);
+    text_log.Print(") = \n");
+    text_log.PushIndent();
+    text_log.Print(m_B[0]);
+    text_log.Print("\n");
+    text_log.PopIndent();
+    DumpDistanceABHelper(text_log,m_A[0],m_B[0]);
+    break;
+
+  case ON_X_EVENT::csx_point:
+    // don't use %g so the text_log double format can control display precision
+    text_log.Print("surfaceB");
+    text_log.Print(ON_2dPoint(m_b[0],m_b[1]));
+    text_log.Print(" = \n");
+    text_log.PushIndent();
+    text_log.Print(m_B[0]);
+    text_log.Print("\n");
+    text_log.PopIndent();
+    DumpDistanceABHelper(text_log,m_A[0],m_B[0]);
+    break;
+
+  case ON_X_EVENT::ccx_overlap:
+    // don't use %g so the text_log double format can control display precision
+    text_log.Print("curveB(");
+    text_log.Print(m_b[0]);
+    text_log.Print(" to ");
+    text_log.Print(m_b[1]);
+    text_log.Print(") = \n");
+    text_log.PushIndent();
+    text_log.Print(m_B[0]);
+    text_log.Print(" to ");
+    text_log.Print(m_B[1]);
+    text_log.Print("\n");
+    text_log.PopIndent();
+    DumpDistanceABHelper(text_log,m_A[0],m_B[0],m_A[1],m_B[1]);
+    break;
+
+  case ON_X_EVENT::csx_overlap:
+    // don't use %g so the text_log double format can control display precision
+    text_log.Print("surface(");
+    text_log.Print(ON_2dPoint(m_b[0],m_b[1]));
+    text_log.Print(" to ");
+    text_log.Print(ON_2dPoint(m_b[2],m_b[3]));
+    text_log.Print(") =  \n");
+    text_log.PushIndent();
+    text_log.Print(m_B[0]);
+    text_log.Print(" to ");
+    text_log.Print(m_B[1]);
+    text_log.Print("\n");
+    text_log.PopIndent();
+    DumpDistanceABHelper(text_log,m_A[0],m_B[0],m_A[1],m_B[1]);
+    break;
+
+  case ON_X_EVENT::no_x_event:
+    break;
+  }
+
+  text_log.Print("m_dirA[] = (");
+  for ( j = 0; j < 2; j++ )
+  {
+    if (j)
+    {
+      text_log.Print(", ");
+    }
+    switch(m_dirA[j])
+    {
+    case ON_X_EVENT::no_x_dir:
+      text_log.Print("no_x_dir");
+      break;
+    case ON_X_EVENT::at_end_dir:
+      text_log.Print("at_end_dir");
+      break;
+    case ON_X_EVENT::from_above_dir:
+      text_log.Print("from_above_dir");
+      break;
+    case ON_X_EVENT::from_below_dir:
+      text_log.Print("from_below_dir");
+      break;
+    case ON_X_EVENT::from_on_dir:
+      text_log.Print("from_on_dir");
+      break;
+    case ON_X_EVENT::to_above_dir:
+      text_log.Print("to_above_dir");
+      break;
+    case ON_X_EVENT::to_below_dir:
+      text_log.Print("to_below_dir");
+      break;
+    case ON_X_EVENT::to_on_dir:
+      text_log.Print("to_on_dir");
+      break;
+    default:
+      text_log.Print("illegal value");
+      break;
+    }
+  }
+  text_log.Print(")\n");
+
+#if defined(OPENNURBS_PLUS_INC_)
+  switch( m_type )
+  {
+  case ON_X_EVENT::ccx_point:
+  case ON_X_EVENT::ccx_overlap:
+    text_log.Print("cnodeA sn = %d,%d  ",m_cnodeA[0]?m_cnodeA[0]->m_nodesn:-1,m_cnodeA[1]?m_cnodeA[1]->m_nodesn:-1);
+    text_log.Print("cnodeB sn = %d,%d\n",m_cnodeB[0]?m_cnodeB[0]->m_nodesn:-1,m_cnodeB[1]?m_cnodeB[1]->m_nodesn:-1);
+    break;
+
+  case ON_X_EVENT::csx_point:
+  case ON_X_EVENT::csx_overlap:
+    text_log.Print("cnodeA sn = %d,%d  ",m_cnodeA[0]?m_cnodeA[0]->m_nodesn:-1,m_cnodeA[1]?m_cnodeA[1]->m_nodesn:-1);
+    text_log.Print("snodeB sn = %d,%d\n",m_snodeB[0]?m_snodeB[0]->m_nodesn:-1,m_snodeB[1]?m_snodeB[1]->m_nodesn:-1);
+    break;
+  }
+#endif
+
+  text_log.PopIndent();
+}
+
+
+double ON_X_EVENT::IntersectionTolerance( double intersection_tolerance )
+{
+  if ( intersection_tolerance <= 0.0 || !ON_IsValid(intersection_tolerance) )
+  {
+    intersection_tolerance = 0.001;
+  }
+  else if ( intersection_tolerance < 1.0e-6 )
+  {
+    intersection_tolerance = 1.0e-6;
+  }
+  return intersection_tolerance;
+}
+
+double ON_X_EVENT::OverlapTolerance( double intersection_tolerance, double overlap_tolerance )
+{
+  if ( overlap_tolerance <= 0.0 || !ON_IsValid(overlap_tolerance) )
+  {
+    overlap_tolerance = 2.0*IntersectionTolerance(intersection_tolerance);
+  }
+  else if ( overlap_tolerance < 1.0e-6 )
+  {
+    overlap_tolerance = 1.0e-6;
+  }
+  return overlap_tolerance;
+}
+
+bool ON_X_EVENT::IsPointEvent() const
+{
+  return (ccx_point == m_type || csx_point == m_type);
+}
+
+bool ON_X_EVENT::IsOverlapEvent() const
+{
+  return (ccx_overlap == m_type || csx_overlap == m_type);
+}
+
+bool ON_X_EVENT::IsCCXEvent() const
+{
+  return (ccx_point == m_type || ccx_overlap == m_type);
+}
+
+bool ON_X_EVENT::IsCSXEvent() const
+{
+  return (csx_point == m_type || csx_overlap == m_type);
+}
+
+
+
+ON_SSX_EVENT::ON_SSX_EVENT()
+{
+  memset(this,0,sizeof(*this));
+}
+
+ON_SSX_EVENT::~ON_SSX_EVENT()
+{
+  if ( m_curveA )
+  {
+    delete m_curveA;
+    m_curveA = 0;
+  }
+  if ( m_curveB )
+  {
+    delete m_curveB;
+    m_curveB = 0;
+  }
+  if ( m_curve3d )
+  {
+    delete m_curve3d;
+    m_curve3d = 0;
+  }
+}
+
+void ON_SSX_EVENT::Dump(ON_TextLog& text_log) const
+{
+ 
+  text_log.Print("m_type: ");
+  switch( m_type )
+  {
+  case ON_SSX_EVENT::no_ssx_event:
+    text_log.Print("no_ssx_event");
+    break;
+  case ON_SSX_EVENT::ssx_transverse:
+    text_log.Print("ssx_transverse");
+    break;
+  case ON_SSX_EVENT::ssx_tangent:
+    text_log.Print("ssx_tangent");
+    break;
+  case ON_SSX_EVENT::ssx_overlap:
+    text_log.Print("ssx_overlap");
+    break;
+  case ON_SSX_EVENT::ssx_transverse_point:
+    text_log.Print("ssx_transverse_point");
+    break;
+	case ON_SSX_EVENT::ssx_tangent_point:
+    text_log.Print("ssx_tangent_point");
+    break;
+  default:
+    text_log.Print("illegal value");
+    break;
+  }
+  text_log.Print("\n");
+  text_log.PushIndent();
+
+  switch( m_type )
+  {
+  case ON_SSX_EVENT::ssx_transverse_point:
+  case ON_SSX_EVENT::ssx_tangent_point:
+    // don't use %g so the text_log double format can control display precision
+    text_log.Print("SurfaceA(");
+    text_log.Print(m_pointA[0]);
+    text_log.Print(",");
+    text_log.Print(m_pointA[1]);
+    text_log.Print(") = \n");
+
+    text_log.Print("SurfaceB(");
+    text_log.Print(m_pointB[0]);
+    text_log.Print(",");
+    text_log.Print(m_pointB[1]);
+    text_log.Print(") = \n");
+
+    text_log.PushIndent();
+    text_log.Print(m_point3d);
+    text_log.Print("\n");
+    text_log.PopIndent();
+    break;
+
+  case ON_SSX_EVENT::no_ssx_event:
+  case ON_SSX_EVENT::ssx_transverse:
+  case ON_SSX_EVENT::ssx_tangent:
+  case ON_SSX_EVENT::ssx_overlap:
+  case ON_SSX_EVENT::ssx_32bit_enum:
+    // these extra cses keep gcc happy and quiet
+    break;
+	}
+}
+
+class ON__SSXTester_Helper {
+public:
+  ON__SSXTester_Helper( ON_TextLog* text_log,
+                    const class ON_Surface* surfaceA,
+                    const class ON_Interval surfaceA_domain[2],
+                    const class ON_Surface* surfaceB,
+                    const class ON_Interval surfaceB_domain[2]);
+  const ON_Surface& SA;
+  const ON_Surface& SB;
+  ON_Interval Adom[2];
+  ON_Interval Bdom[2];
+
+  ON_TextLog* log;
+
+  double tol;
+  bool TestDir;
+
+  bool TestPoint( ON_2dPoint A, ON_2dPoint B, ON_3dPoint P , double* error=NULL);
+
+private:
+  // no implementation
+  ON__SSXTester_Helper& operator=(const ON__SSXTester_Helper&);
+};
+
+bool ON_SSX_EVENT::IsValid(
+        ON_TextLog* text_log,
+        double intersection_tolerance,
+        double overlap_tolerance,
+        double fitting_tolerance,
+        const class ON_Surface* surfaceA,
+        const class ON_Interval* surfaceA_domain0,
+        const class ON_Interval* surfaceA_domain1,
+        const class ON_Surface* surfaceB,
+        const class ON_Interval* surfaceB_domain0,
+        const class ON_Interval* surfaceB_domain1
+        ) const
+{
+  ON_Interval ADomain[2];
+  ON_Interval BDomain[2];
+
+  double xtol = intersection_tolerance;
+  double otol = overlap_tolerance;
+  double ftol = fitting_tolerance;
+
+  if( surfaceA==NULL)
+  {
+     ON_ERROR("ON_SSX_EVENT::IsValid - No surfaceA passed in");
+     return false;
+  }
+
+  if( surfaceB==NULL)
+  {
+     ON_ERROR("ON_SSX_EVENT::IsValid - No surfaceB passed in");
+     return false;
+  }
+
+  // fill in default tolerance values
+  if ( !ON_IsValid(xtol) || xtol <= 0.0 )
+    xtol = 0.001;
+  if ( !ON_IsValid(otol) || otol <= 0.0 )
+    otol = 2.0*xtol;
+  if ( !ON_IsValid(ftol) || ftol <= 0.0 )
+  {
+    ftol = xtol;
+    if ( ftol < 0.0001 ) //GBA 15 Nov 2007 . I changed this from .001 to .0001
+      ftol = 0.0001;
+  }
+
+
+  // Check domain parameters
+ if(surfaceA_domain0)
+ {
+    if ( !surfaceA_domain0->IsIncreasing() )
+    {
+      ON_ERROR("ON_SSX_EVENT::IsValid - Bogus surfaceA_domain0 passed in");
+      surfaceA_domain0 = NULL;
+    }    
+ }
+ if(surfaceA_domain1)
+ {
+    if ( !surfaceA_domain1->IsIncreasing() )
+    {
+      ON_ERROR("ON_SSX_EVENT::IsValid - Bogus surfaceA_domain1 passed in");
+      surfaceA_domain1 = NULL;
+    }    
+ }
+ if(surfaceB_domain0)
+ {
+    if ( !surfaceB_domain0->IsIncreasing() )
+    {
+      ON_ERROR("ON_SSX_EVENT::IsValid - Bogus surfaceB_domain0 passed in");
+      surfaceB_domain0 = NULL;
+    }    
+ }
+ if(surfaceB_domain1)
+ {
+    if ( !surfaceB_domain1->IsIncreasing() )
+    {
+      ON_ERROR("ON_SSX_EVENT::IsValid - Bogus surfaceB_domain1 passed in");
+      surfaceB_domain1 = NULL;
+    }    
+ }
+
+ ON_Interval dom;
+ ADomain[0]=surfaceA->Domain(0);
+ if( surfaceA_domain0)
+ {
+    dom.Intersection( ADomain[0], *surfaceA_domain0);
+    if(dom.IsEmptySet())
+      ON_ERROR("ON_SSX_EVENT::IsValid() surfaceA_domain0 is disjoint from SurfaceA->Domain(0)");
+    else
+      ADomain[0]=dom;
+ }
+
+ ADomain[1]=surfaceA->Domain(1);
+ if( surfaceA_domain1)
+ {
+    dom.Intersection( ADomain[1], *surfaceA_domain1);
+    if(dom.IsEmptySet())
+      ON_ERROR("ON_SSX_EVENT::IsValid() surfaceA_domain1 is disjoint from SurfaceA->Domain(1)");
+    else
+      ADomain[1]=dom;
+ }
+
+ BDomain[0]=surfaceB->Domain(0);
+ if( surfaceB_domain0)
+ {
+    dom.Intersection( BDomain[0], *surfaceB_domain0);
+    if(dom.IsEmptySet())
+      ON_ERROR("ON_SSX_EVENT::IsValid() surfaceB_domain0 is disjoint from SurfaceB->Domain(0)");
+    else
+      BDomain[0]=dom;
+ }
+
+ BDomain[1]=surfaceB->Domain(1);
+ if( surfaceB_domain1)
+ {
+    dom.Intersection( BDomain[1], *surfaceB_domain1);
+    if(dom.IsEmptySet())
+      ON_ERROR("ON_SSX_EVENT::IsValid() surfaceB_domain1 is disjoint from SurfaceB->Domain(1)");
+    else
+      BDomain[1]=dom;
+ }
+
+  bool rc = true;
+  double dist = ON_UNSET_VALUE;
+  ON_3dPoint A;
+  ON_3dPoint B ;
+
+  if(text_log)
+    text_log->SetIndentSize(6);
+
+  switch(m_type)
+  {
+  case no_ssx_event:
+    if ( text_log )
+      text_log->Print("ON_SSX_EVENT::m_type = no_ssx_event - should be set to a valid value.\n");
+    return false;
+
+  case ssx_transverse:
+    {
+      if( !m_curveA || !m_curveB || !m_curve3d)
+      {
+        if(text_log)
+          text_log->Print("ON_SSX_EVENT::m_curve** == NULL for an ssx_transverse event.\n");
+        return false; 
+      }
+
+      m_curveA->IsValid( text_log);
+      m_curveB->IsValid( text_log);
+      m_curve3d->IsValid( text_log);
+
+      ON_Interval cdom= m_curve3d->Domain();
+      ON_Interval adom = m_curveA->Domain();
+      ON_Interval bdom = m_curveB->Domain();
+      if( adom!=cdom)
+      {
+        if( text_log)
+          text_log->Print("ON_SSX_EVENT::m_curve3d->Domain() != m_curveA->Domain().\n");
+        rc = false;
+      }
+      if( bdom!=cdom)
+      {
+        if( text_log)
+          text_log->Print("ON_SSX_EVENT::m_curve3d->Domain() != m_curveB->Domain().\n");
+        rc = false;
+      }
+      int cvcnt = 8;
+      ON_NurbsCurve* nc = ON_NurbsCurve::Cast(m_curve3d);
+      if(nc && nc->CVCount()>cvcnt)
+        cvcnt = nc->CVCount();
+      nc = ON_NurbsCurve::Cast(m_curveA);
+      if(nc && nc->CVCount()>cvcnt)
+        cvcnt = nc->CVCount(); 
+      nc = ON_NurbsCurve::Cast(m_curveB);
+      if(nc && nc->CVCount()>cvcnt)
+        cvcnt = nc->CVCount();
+      
+      ON__SSXTester_Helper TestIt(text_log,  surfaceA,  ADomain, surfaceB, BDomain); 
+      TestIt.tol = ftol;
+
+      cvcnt = (cvcnt-3)*5;
+
+      ON_3dPoint P;
+      ON_2dPoint A,B;
+      bool ok = true;
+      ON_wString smax_log;
+      ON_wString sfirst_log;
+      ON_wString spoint_log;
+
+      double t=ON_UNSET_VALUE;
+      double maxerr = 0;
+      for(int i=0;  i<=cvcnt; i++)
+      {
+        double err=0;
+        ON_wString spoint_log;
+        ON_TextLog point_log(spoint_log);
+        TestIt.log = &point_log;
+
+        t = cdom.ParameterAt( double(i)/cvcnt);
+        P = m_curve3d->PointAt(t);
+        A = m_curveA->PointAt(t);
+        B = m_curveB->PointAt(t);
+        if( !TestIt.TestPoint(A, B, P, &err))
+        {
+					if(err>maxerr)
+          {
+            maxerr = err;
+            smax_log = spoint_log;
+          }
+					else if( ok){
+						sfirst_log = spoint_log;
+					}
+          ok = false; 
+        }
+      }
+      if(!ok)
+      {
+        if(text_log)
+        {
+          text_log->Print("ON_SSX_EVENT: Curve point at parameter %g not valid intersection point:\n", t);
+          text_log->PushIndent();
+          text_log->Print( sfirst_log );
+          text_log->Print( smax_log );
+          text_log->PopIndent();
+        }
+      }
+      if (rc)
+        rc = ok;
+      break;
+    }
+
+  case ssx_tangent:
+    {
+      if( !m_curveA || !m_curveB || !m_curve3d)
+      {
+        if(text_log)
+          text_log->Print(" m_curve** == NULL for an ssx_tangent event.\n");
+        return false; 
+      }
+
+      m_curveA->IsValid( text_log);
+      m_curveB->IsValid( text_log);
+      m_curve3d->IsValid( text_log);
+
+      ON_Interval cdom= m_curve3d->Domain();
+      ON_Interval adom = m_curveA->Domain();
+      ON_Interval bdom = m_curveB->Domain();
+      if( adom!=cdom)
+      {
+        if( text_log)
+         text_log->Print("  ON_SSX_EVENT m_curve3d->Domain() != m_curveA->Domain().\n");
+      }
+      if( bdom!=cdom)
+      {
+        if( text_log)
+         text_log->Print("  ON_SSX_EVENT m_curve3d->Domain() != m_curveB->Domain().\n");
+      }
+      int cvcnt = 8;
+      ON_NurbsCurve* nc = ON_NurbsCurve::Cast(m_curve3d);
+      if(nc && nc->CVCount()>cvcnt)
+        cvcnt = nc->CVCount();
+      nc = ON_NurbsCurve::Cast(m_curveA);
+      if(nc && nc->CVCount()>cvcnt)
+        cvcnt = nc->CVCount(); 
+      nc = ON_NurbsCurve::Cast(m_curveB);
+      if(nc && nc->CVCount()>cvcnt)
+        cvcnt = nc->CVCount();
+      
+      ON__SSXTester_Helper TestIt(text_log,  surfaceA,  ADomain, surfaceB, BDomain); 
+      TestIt.tol = xtol;
+      TestIt.log = text_log;
+
+      cvcnt = (cvcnt-3)*5;
+
+      ON_3dPoint P;
+      ON_2dPoint A,B;
+      bool ok = true;
+      for(int i=0; ok && i<=cvcnt; i++)
+      {
+        double t = cdom.ParameterAt( double(i)/cvcnt);
+        P = m_curve3d->PointAt(t);
+        A = m_curveA->PointAt(t);
+        B = m_curveB->PointAt(t);
+        ok = TestIt.TestPoint(A, B, P);
+      }
+      rc = ok;
+      break;
+    }
+
+
+  case ssx_overlap:
+    if( !m_curveA || !m_curveB || !m_curve3d)
+    {
+      if(text_log)
+        text_log->Print(" m_curve** == NULL for an ssx_overlap event.\n");
+      return false; 
+    }
+
+    m_curveA->IsValid( text_log);
+    m_curveB->IsValid( text_log);
+    m_curve3d->IsValid( text_log);
+    //todo ...
+
+    break;
+
+  case ssx_tangent_point:
+    if( m_curveA || m_curveB || m_curve3d)
+    {
+      if( text_log)
+        text_log->Print("ON_SSX_EVENT:m_curve* !=NULL for an ssx_tangent_point event.\n");
+      rc = false;
+    }
+
+    if( m_pointA.z!=0)
+    {
+       if( text_log)
+         text_log->Print("ON_SSX_EVENT::m_pointA.z != 0.0 for an ssx_tangent_point event.\n");
+       rc = false;
+    }
+    if( m_pointB.z!=0)
+    {
+       if( text_log)
+         text_log->Print("ON_SSX_EVENT::m_pointB.z != 0.0 for an ssx_tangent_point event.\n");
+       rc = false;
+    }
+
+    if( !ADomain[0].Includes(m_pointA.x) || !ADomain[1].Includes(m_pointA.y) )
+    {
+      if( text_log)
+        text_log->Print("  m_pointA outside of surfaceA.Domain().\n");
+      rc = false;
+    }
+    if( !BDomain[0].Includes(m_pointB.x) || !BDomain[1].Includes(m_pointB.y) )
+    {
+      if( text_log)
+        text_log->Print("  m_pointB outside of surfaceB.Domain().\n");
+      rc = false;
+    }
+    if(!rc)
+      return false;
+
+    A = surfaceA->PointAt( m_pointA.x, m_pointA.y );
+    B = surfaceA->PointAt( m_pointB.x, m_pointB.y );
+    dist = A.DistanceTo(m_point3d);
+    if(dist>xtol)
+    {
+      if(text_log)
+        text_log->Print(" SurfaceA->PointAt( m_pointA).DistanceTo(m_point3d)=%g > intersection_tolerance = &g.\n", dist, xtol); 
+      rc = false;
+    }
+    dist = B.DistanceTo(m_point3d);
+    if(dist>xtol)
+    {
+      if(text_log)
+        text_log->Print(" SurfaceB->PointAt( m_pointA).DistanceTo(m_point3d)=%g > intersection_tolerance = &g.\n", dist, xtol); 
+      rc = false;
+    }
+    dist = B.DistanceTo(A);
+    if(dist>xtol)
+    {
+      if(text_log)
+        text_log->Print(" SurfaceB->PointAt( m_pointA).DistanceTo(SurfaceB->PointAt( m_pointB))=%g > intersection_tolerance = &g.\n", dist, xtol); 
+      rc = false;
+    }
+    break;
+
+  case ssx_transverse_point:
+    if( m_curveA || m_curveB || m_curve3d)
+    {
+      if( text_log)
+        text_log->Print("ON_SSX_EVENT:m_curve* !=NULL for an ssx_transverse_point event.\n");
+      rc = false;
+    }
+
+   if( m_pointA.z!=0)
+    {
+       if( text_log)
+         text_log->Print("ON_SSX_EVENT::m_pointA.z != 0.0 for an ssx_transverse_point event.\n");
+       rc = false;
+    }
+    if( m_pointB.z!=0)
+    {
+       if( text_log)
+         text_log->Print("ON_SSX_EVENT::m_pointB.z != 0.0 for an ssx_transverse_point event.\n");
+       rc = false;
+    }
+
+
+
+    if( !ADomain[0].Includes(m_pointA.x) || !ADomain[1].Includes(m_pointA.y) )
+    {
+      if( text_log)
+        text_log->Print("  m_pointA outside of surfaceA.Domain().\n");
+      rc = false;
+    }
+    if( !BDomain[0].Includes(m_pointB.x) || !BDomain[1].Includes(m_pointB.y) )
+    {
+      if( text_log)
+        text_log->Print("  m_pointB outside of surfaceB.Domain().\n");
+      rc = false;
+    }
+    if(!rc)
+      return false;
+
+    A = surfaceA->PointAt( m_pointA.x, m_pointA.y );
+    B = surfaceB->PointAt( m_pointB.x, m_pointB.y );
+    dist = A.DistanceTo(m_point3d);
+    if(dist>xtol)
+    {
+      if(text_log)
+        text_log->Print(" SurfaceA->PointAt( m_pointA).DistanceTo(m_point3d)=%g > intersection_tolerance = &g.\n", dist, xtol); 
+      rc = false;
+    }
+    dist = B.DistanceTo(m_point3d);
+    if(dist>xtol)
+    {
+      if(text_log)
+        text_log->Print(" SurfaceB->PointAt( m_pointA).DistanceTo(m_point3d)=%g > intersection_tolerance = &g.\n", dist, xtol); 
+      rc = false;
+    }
+    dist = B.DistanceTo(A);
+    if(dist>xtol)
+    {
+      if(text_log)
+        text_log->Print(" SurfaceB->PointAt( m_pointA).DistanceTo(SurfaceB->PointAt( m_pointB))=%g > intersection_tolerance = &g.\n", dist, xtol); 
+      rc = false;
+    }
+    break;
+
+  default:
+    if ( text_log )
+      text_log->Print("ON_SSX_EVENT.m_type set to undefined value.\n");
+    return false;
+  }
+ 
+ return rc;
+}
+
+bool ON_SSX_EVENT::IsPointEvent() const
+{
+  return (    ON_SSX_EVENT::ssx_transverse_point == m_type 
+           || ON_SSX_EVENT::ssx_tangent_point == m_type);
+}
+
+bool ON_SSX_EVENT::IsTinyEvent(double tiny_tolerance) const
+{
+  if (    ON_SSX_EVENT::ssx_transverse_point == m_type 
+       || ON_SSX_EVENT::ssx_tangent_point == m_type
+     )
+    return true; // point event is always "tiny"
+
+  if (   ON_SSX_EVENT::ssx_transverse != m_type 
+      && ON_SSX_EVENT::ssx_tangent    != m_type
+      && ON_SSX_EVENT::ssx_overlap    != m_type
+      )
+    return false;
+
+  if ( !m_curve3d )
+    return false;
+
+  if ( tiny_tolerance <= 0.0 || !ON_IsValid(tiny_tolerance) )
+    return false;
+
+
+  // quick endpoint check to avoid bounding box
+  // calculation in most cases
+  ON_3dPoint P0 = m_curve3d->PointAtStart();
+  ON_3dPoint P1 = m_curve3d->PointAtEnd();
+  if ( !P0.IsValid() )
+    return false;
+  if ( !P1.IsValid() )
+    return false;
+  if ( fabs(P0.x-P1.x) > tiny_tolerance )
+    return false;
+  if ( fabs(P0.y-P1.y) > tiny_tolerance )
+    return false;
+  if ( fabs(P0.z-P1.z) > tiny_tolerance )
+    return false;
+
+  // check m_curve3d's bounding box
+  P0.z = P1.z = 0.0;
+  if ( !m_curve3d->GetBBox(&P0.x,&P1.x,false) )
+    return false;
+  if ( fabs(P0.x-P1.x) > tiny_tolerance )
+    return false;
+  if ( fabs(P0.y-P1.y) > tiny_tolerance )
+    return false;
+  if ( fabs(P0.z-P1.z) > tiny_tolerance )
+    return false;
+
+  return true; // curve event is "tiny"
+}
+
+
+bool ON_SSX_EVENT::IsCurveEvent() const
+{
+  return (ON_SSX_EVENT::ssx_transverse == m_type || ON_SSX_EVENT::ssx_tangent == m_type);
+}
+
+bool ON_SSX_EVENT::IsTangentEvent() const
+{
+  return (ON_SSX_EVENT::ssx_tangent == m_type || ON_SSX_EVENT::ssx_tangent_point == m_type);
+}
+
+bool ON_SSX_EVENT::IsOverlapEvent() const
+{
+  return (ON_SSX_EVENT::ssx_overlap == m_type);
+}
+
+// helper class for test intersection points
+
+
+ON__SSXTester_Helper::ON__SSXTester_Helper(ON_TextLog* text_log,
+                    const class ON_Surface* surfaceA,
+                    const class ON_Interval surfaceA_domain[2],
+                    const class ON_Surface* surfaceB,
+                    const class ON_Interval surfaceB_domain[2]) :
+SA(*surfaceA), SB(*surfaceB) 
+{
+	Adom[0] = surfaceA_domain[0];
+	Adom[1] = surfaceA_domain[1]; 
+	Bdom[0] = surfaceB_domain[0]; 
+    Bdom[1] = surfaceB_domain[1]; 
+   tol = .01;
+
+   log = text_log;
+}
+
+bool ON__SSXTester_Helper::TestPoint(ON_2dPoint A, ON_2dPoint B, ON_3dPoint P, double* error)
+{
+  bool rc = true;
+  double err=0;
+
+  if( !Adom[0].Includes(A.x) || !Adom[1].Includes(A.y) )
+  {
+    if(log)
+      log-> Print("  Point a outside of SurfaceA domain.\n");
+    rc = false;
+  }
+  if( !Bdom[0].Includes(B.x) || !Bdom[1].Includes(B.y) )
+  {
+    if(log)
+      log-> Print("  Point b outside of SurfaceB domain.\n");
+    rc = false;
+  }
+
+  return false;
+#if 0
+  double dist;
+
+  ON_2dPoint st, uv;
+  st = A;
+  SA.GetLocalClosestPoint(P, A.x, A.y, &st.x, &st.y, &Adom[0], &Adom[1] );
+  ON_3dPoint PA = SA.PointAt(st.x, st.y); 
+  dist = P.DistanceTo(PA);
+
+  if( dist>tol)
+  {
+    if(log)
+      log->Print(" Distance(P, Srf_A) = %g > tolerance = %g.\n", dist, tol);
+    rc = false;
+    if(dist>err) err = dist;
+  }
+  uv = B;
+  SB.GetLocalClosestPoint(P, uv.x, uv.y, &uv.x, &uv.y, &Bdom[0], &Bdom[1] );
+  ON_3dPoint PB = SB.PointAt(uv.x, uv.y); 
+  dist = P.DistanceTo(PB);
+
+  if( dist>tol)
+  {
+    if(log)
+      log->Print(" Distance(P, Srf_B) = %g > tolerance = %g.\n", dist, tol);
+    rc = false;
+    if(dist>err) err = dist;
+  }
+
+
+  PA = SA.PointAt(A.x, A.y);
+  SB.GetLocalClosestPoint(PA, B.x, B.y, &uv.x, &uv.y, &Bdom[0], &Bdom[1] );
+  PB = SB.PointAt(uv.x, uv.y); 
+  dist = PA.DistanceTo(PB);
+  if( dist>tol)
+  {
+    if(log)
+      log->Print(" Distance(S(A), Srf_B) = %g > tolerance = %g.\n", dist, tol);
+    rc = false;
+    if(dist>err) err = dist;
+  }
+
+  PB = SB.PointAt(B.x, B.y);
+  SA.GetLocalClosestPoint(PB, A.x, A.y, &st.x, &st.y, &Adom[0], &Adom[1] );
+  PA = SA.PointAt(st.x, st.y); 
+  dist = PA.DistanceTo(PB);
+  if( dist>tol)
+  {
+    if(log)
+      log->Print(" Distance(S(B), Srf_A) = %g > tolerance = %g.\n", dist, tol);
+    rc = false;
+    if(dist>err) err = dist;
+  }
+
+  if(!rc && error)
+    *error = err;
+  return rc;
+#endif
+}
+
--- opennurbs/opennurbs_x.h	1969-12-31 19:00:00.000000000 -0500
+++ openNURBS/opennurbs_x.h	2023-09-09 13:43:33.732976101 -0400
@@ -0,0 +1,628 @@
+/* $NoKeywords: $ */
+/*
+//
+// Copyright (c) 1993-2007 Robert McNeel & Associates. All rights reserved.
+// Rhinoceros is a registered trademark of Robert McNeel & Assoicates.
+//
+// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
+// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
+// MERCHANTABILITY ARE HEREBY DISCLAIMED.
+//				
+// For complete openNURBS copyright information see <http://www.opennurbs.org>.
+//
+////////////////////////////////////////////////////////////////
+*/
+
+#if !defined(OPENNURBS_X_INC_)
+#define OPENNURBS_X_INC_
+
+// The ON_X_EVENT class is used to report curve-curve and curve-surface
+// intersection events.
+class ON_CLASS ON_X_EVENT
+{
+  // NO VIRTUAL FUNCTIONS IN THIS CLASS
+public:
+  
+  // Default construction sets everything to zero.
+  ON_X_EVENT();
+
+  // This class must use default copy constructor, operator=, and destructor.
+
+  /*
+  Description:
+    Compares intersection events and sorts them in the 
+    canonical order.
+  Returns:
+    @untitled table
+    -1    this  < other
+     0    this == other
+    +1    this  > other
+  Remarks:
+    ON_CX_EVENT::Compare is used to sort intersection events into canonical
+    order.
+  */
+  static
+  int Compare( const ON_X_EVENT* a, const ON_X_EVENT* b );
+
+  void Dump(ON_TextLog& text_log) const;
+
+  /*
+  Description:
+    Check intersection event values to make sure they are valid.
+  Parameters:
+    text_log - [in] If not null and an error is found, then a description
+                    of the error is printed to text_log.
+    intersection_tolerance - [in] 
+         0.0 or value used in intersection calculation.
+    overlap_tolerance - [in] 
+         0.0 or value used in intersection calculation.
+    curveA - [in] 
+         NULL or curveA passed to intersection calculation.
+    curveA_domain - [in] 
+         NULL or curveA domain used in intersection calculation.
+    curveB - [in]
+         NULL or curveB passed to intersection calculation.
+    curveB_domain - [in]
+         NULL or curveB domain used in intersection calculation.
+    surfaceB - [in]
+         NULL or surfaceB passed to intersection calculation.
+    surfaceB_domain0 - [in]
+         NULL or surfaceB "u" domain used in intersection calculation.
+    surfaceB_domain1 - [in]
+         NULL or surfaceB "v" domain used in intersection calculation.
+  Returns:
+    True if event is valid.
+  */
+  bool IsValid(
+          ON_TextLog* text_log,
+          double intersection_tolerance,
+          double overlap_tolerance,
+          const class ON_Curve* curveA,
+          const class ON_Interval* curveA_domain,
+          const class ON_Curve* curveB,
+          const class ON_Interval* curveB_domain,
+          const class ON_Surface* surfaceB,
+          const class ON_Interval* surfaceB_domain0,
+          const class ON_Interval* surfaceB_domain1
+          ) const;
+
+
+  /*
+  Description:
+    Expert user tool to copy portions of the itersection
+    event information from one event to another.  
+    If src.m_type is ON_X_EVENT::csx_*, then the
+    m_b[] and m_nodeB_t[] values are treated as
+    surface parameters, otherwise the values are
+    treated as curve parameters.  The m_type field
+    is not copied.
+  Parameters:
+    src - [in]
+    src_end - [in] 0 or 1 (m_A[] source index)
+    dst - [out]
+    dst_end - [in] 0 or 1 (m_A[] destination index)
+  */
+  static 
+  void CopyEventPart(
+        const ON_X_EVENT& src, 
+        int src_end,
+        ON_X_EVENT& dst, 
+        int dst_end 
+        );
+
+  /*
+  Description:
+    Expert user tool to cleanup a list of intersection 
+    events.
+  Parameters:
+    event_tolerance - [in] If the distance between
+      events is <= event_tolerance, they will
+      be considered to be the same event.  Typically,
+      event_tolerance is "small" and
+      event_tolerance <= intersection_tolerance.
+
+    overlap_tolerance - [in] minimum length for an
+      intersection overlap segment. Typically,
+      overlap_tolerance is "large" and
+      overlap_tolerance > intersection_tolerance
+
+    xevent_count - [in]
+    xevent - [in/out]
+  Returns:
+    Length of cleaned list.
+  */
+  static
+  int CleanList(
+          double event_tolerance,
+          double overlap_tolerance,
+          int xevent_count,
+          ON_X_EVENT* xevent
+          );
+
+  /*
+  Description:
+    Expert user tool to check a list of intersection events.
+  Parameters:
+    xevent_count - [in]
+    xevent - [in]
+    text_log - [in] NULL or place to describe errors.
+    intersection_tolerance - [in]
+    overlap_tolerance - [in]
+    curveA - [in]
+    curveA_domain - [in] (can be NULL)
+    curveB - [in] (NULL for curve-surface intersection events)
+    curveB_domain - [in] (can be NULL)
+    surfaceB - [in] (NULL for curve-curve intersection events)
+    surfaceB_domain0 - [in] (can be NULL)
+    surfaceB_domain1 - [in] (can be NULL)
+  Returns:
+    True if list is valid.
+  */
+  static
+  bool IsValidList(
+          int xevent_count,
+          const ON_X_EVENT* xevent,
+          ON_TextLog* text_log,
+          double intersection_tolerance,
+          double overlap_tolerance,
+          const class ON_Curve* curveA,
+          const class ON_Interval* curveA_domain,
+          const class ON_Curve* curveB,
+          const class ON_Interval* curveB_domain,
+          const class ON_Surface* surfaceB,
+          const class ON_Interval* surfaceB_domain0,
+          const class ON_Interval* surfaceB_domain1
+          );
+
+  /*
+  Description:
+    Do a quick and simple test to see if this curve
+    lies on some portion of curveB.
+  Parameters:
+    curveA_domain - [in] non empty interval
+    sample_count - [in] minimum number of test points
+    overlap_tolerance - [in]
+    cnodeA - [in]
+    cnodeB - [in]
+    curveB_domain - [in] optional domain restriction
+  Returns:
+    True if sections overlap.
+  */
+  static
+  bool IsValidCurveCurveOverlap( 
+        ON_Interval curveA_domain,
+        int sample_count,
+        double overlap_tolerance,
+        const class ON_CurveTreeNode* cnodeA, 
+        const class ON_CurveTreeNode* cnodeB,
+        const ON_Interval* curveB_domain = 0
+        );
+
+  /*
+  Description:
+    Do a quick and simple test to see if this curve
+    lies on the plane.
+  Parameters:
+    curveA_domain - [in]  non empty interval
+    sample_count - [in] minimum number of test points
+    endpont_tolerance - [in] tolerance to use when checking ends
+    overlap_tolerance - [in] tolerance to use when checking interior
+    cnodeA - [in]
+    plane_equation - [in]
+  Returns:
+    True if curve lies on the plane
+  */
+  static 
+  bool IsValidCurvePlaneOverlap( 
+        ON_Interval curveA_domain,
+        int sample_count,
+        double endpoint_tolerance,
+        double overlap_tolerance,
+        const class ON_CurveTreeNode* cnodeA,
+        const ON_PlaneEquation* plane_equation
+        );
+
+  /*
+  Description:
+    Do a quick and simple test to see if this curve
+    lies on the surface.
+  Parameters:
+    curveA_domain - [in]  non empty interval
+    sample_count - [in] minimum number of test points
+    overlap_tolerance - [in]
+    cnodeA - [in]
+    snodeB - [in]
+    surfaceB_udomain - [in] optional domain restriction
+    surfaceB_vdomain - [in] optional domain restriction
+  Returns:
+    True if sections overlap.
+  */
+  static 
+  bool IsValidCurveSurfaceOverlap( 
+        ON_Interval curveA_domain,
+        int sample_count,
+        double overlap_tolerance,
+        const class ON_CurveTreeNode* cnodeA, 
+        const class ON_SurfaceTreeNode* snodeB,
+        const ON_Interval* surfaceB_udomain = 0,
+        const ON_Interval* surfaceB_vdomain = 0
+        );
+
+  /*
+  Description:
+    Convert input intersection tolerance to value used
+    in calculations.
+  Parameters:
+    intersection_tolerance - [in]
+  Returns:
+    Value use in intersection calculations.
+  */
+  static
+  double IntersectionTolerance( double intersection_tolerance );
+
+  /*
+  Description:
+    Convert input intersection tolerance to value used
+    in calculations.
+  Parameters:
+    intersection_tolerance - [in]
+  Returns:
+    Value use in intersection calculations.
+  */
+  static
+  double OverlapTolerance( double intersection_tolerance, double overlap_tolerance );
+
+  /*
+  Returns:
+    True if m_type is ccx_point or csx_point.
+  */
+  bool IsPointEvent() const;
+
+  /*
+  Returns:
+    True if m_type is ccx_overlap or csx_overlap.
+  */
+  bool IsOverlapEvent() const;
+
+  /*
+  Returns:
+    True if m_type is ccx_point or ccx_overlap
+  */
+  bool IsCCXEvent() const;
+
+  /*
+  Returns:
+    True if m_type is csx_point or csx_overlap
+  */
+  bool IsCSXEvent() const;
+
+
+  enum TYPE
+  { 
+    no_x_event  =  0,
+
+    // Two valid event types for curve-curve intersections
+    ccx_point   =  1, // curve-curve transverse intersection point
+    ccx_overlap =  2, // curve-curve intersection overlap
+
+    // Two valid event types for curve-surface intersections
+    csx_point   =  3, // curve-surface transverse intersection point
+    csx_overlap =  4  // curve-surface intersection overlap
+  };
+
+  // Event directions for use in the m_dirA[] and m_dirB[]
+  // fields. The "x_from_*" values are used to report the 
+  // behavior of the curve as it enters the intersection 
+  // event. The "x_to_*" values are used to report the 
+  // behavior of the curve as it leaves the intersection
+  // event.
+  enum DIRECTION
+  { 
+    no_x_dir       = 0, 
+
+    at_end_dir     = 1, // event is at the start/end/side of object's
+                        // parameter space
+
+    from_above_dir = 2, // curve enters x-event from above surface/other curve
+    from_below_dir = 3, // curve enters x-event from below surface/other curve
+    from_on_dir    = 4, // curve enters x-event tangent surface/other curve
+
+    to_above_dir   = 5, // curve leaves x-event above surface/other curve
+    to_below_dir   = 6, // curve leaves x-event below surface/other curve
+    to_on_dir      = 7  // curve leaves x-event tangent to surface/other curve
+  };
+
+  // This field is a scratch field for users.
+  // The constructor sets it to zero and the 
+  // intersectors never use it.
+  ON_U m_user;
+
+  // The m_type field determines how the values in the other
+  // fields are interpreted.  See the detailed comment below
+  // for complete informtion
+  TYPE m_type;
+
+  ON_3dPoint m_A[2]; // intersection points on first curve
+  ON_3dPoint m_B[2]; // intersection points on second curve or surface
+  double m_a[2];     // intersection parameters on first curve
+  double m_b[4];     // intersection parameters on second curve or surface
+  
+  // There are cases when it is valuable to have direction
+  // flags on intersection events.  The m_dirA[] and m_dirB[]
+  // fields provide a place to store these flags.  Because this
+  // information is rarely used, it is not computed by the
+  // intersection routines.  You can use
+  //   ON_SetCurveCurveIntersectionDir 
+  // or
+  //   ON_SetCurveSurfaceIntersectionDir
+  // to fill in these fields.
+  DIRECTION m_dirA[2];
+  DIRECTION m_dirB[2];
+
+  // tree nodes where the intersection events occured.
+  const class ON_CurveTreeNode* m_cnodeA[2];
+  double m_nodeA_t[2]; // nodeA bezier paramters corresponding to a[] values 
+  const class ON_CurveTreeNode* m_cnodeB[2];
+  const class ON_SurfaceTreeNode* m_snodeB[2];
+  double m_nodeB_t[4]; // nodeB bezier paramters corresponding to b[] values.
+
+  // Each intersection event is assigned a runtime serial number.
+  unsigned int m_x_eventsn;
+
+  /*
+  The m_type field determines how the values in the other
+  fields are interpreted.
+
+    ccx_point events:
+      a[0] = a[1] = first curve parameter
+      A[0] = A[1] = intersection point on first curve
+      b[0] = b[1] = second curve parmeter
+      B[0] = B[1] = intersection point on second curve
+      b[2] = b[3] = not used
+      cnodeA[0] = cnodeA[1] = pointer to first curve's tree node
+      cnodeB[0] = cnodeB[1] = pointer to second curve's tree node
+      snodeB[0] = snodeB[1] = 0
+
+    ccx_overlap events:
+      (a[0],a[1]) = first curve parameter range (a[0] < a[1])
+      A[0] = intersection start point on first curve
+      A[1] = intersection end point on first curve
+      (b[0],b[1]) = second curve parameter range (b[0] != b[1])
+      B[0] = intersection start point on second curve
+      B[1] = intersection end point on second curve
+      b[2] = b[3] = not used
+      cnodeA[0] = pointer to first curve's tree node for start point
+      cnodeA[1] = pointer to first curve's tree node for end point
+      cnodeB[0] = pointer to second curve's tree node for start point
+      cnodeB[1] = pointer to second curve's tree node for end point
+      snodeB[0] = snodeB[1] = 0
+   
+   csx_point events:
+      a[0] = a[1] = curve parameter
+      A[0] = A[1] = intersection point on curve
+      (b[0],b[1]) = (b[2],b[3]) = surface parameter
+      B[0] = B[1] intersection point on surface
+      cnodeA[0] = cnodeA[1] = pointer to curve's tree node
+      cnodeB[0] = cnodeB[1] = 0;
+      snodeB[0] = snodeB[1] = pointer to surface's tree node
+
+    csx_overlap events:
+      (a[0],a[1]) = curve parmamter range (a[0] < a[1])
+      A[0] = intersection start point on first curve
+      A[1] = intersection end point on first curve
+      (b[0],b[1]) = surface parameter for curve(a[0]).
+      B[0] = intersection start point on surface
+      (b[2],b[3]) = surface parameter for curve(a[1]).
+      B[1] = intersection end point on surface
+      cnodeA[0] = pointer to curve's tree node for start point
+      cnodeA[1] = pointer to curve's tree node for end point
+      snodeB[0] = pointer to surface's tree node for start point
+      snodeB[1] = pointer to surface's tree node for end point
+  */
+};
+
+
+
+/*
+Description:
+  Sets ON_X_EVENT m_dirA[] and m_dirB[] flags for in intersection
+  of coplanar curves.  For each  m_dirA[]/m_dirB[] flag that is 
+  set to ON_X_EVENT, the curve geometry at the itersection is
+  examined to set the flags.
+Parameters:
+  N [in] normal to the plane
+  xcount - [in] number of intersection events
+  xevent - [in] array of xcount intersection events
+  a0 - [in]
+  a1 - [in] (a0,a1) = curveA intersection domain
+  b0 - [in]
+  b1 - [in] (b0,b1) = curveB intersection domain
+See Also:
+  ON_Curve::IntersectCurve
+  ON_SetCurveSurfaceIntersectionDir
+*/
+ON_DECL
+bool ON_SetCurveCurveIntersectionDir(
+            ON_3dVector N,
+            int xcount,
+            ON_X_EVENT* xevent,
+            double a0,
+            double a1,
+            double b0,
+            double b1
+            );
+
+
+/*
+Description:
+  Sets ON_X_EVENT m_dirA[] and m_dirB[] flags for a curve surface
+  intersection.  For each  m_dirA[]/m_dirB[] flag that is 
+  set to ON_X_EVENT, the curve and surface geometry at the 
+  itersection is examined to set the flags.
+Parameters:
+  xcount - [in] number of intersection events
+  xevent - [in] array of xcount intersection events
+  t0 - [in]
+  t1 - [in] (t0,t1) = curveA intersection domain
+  u0 - [in]
+  u1 - [in] (u0,u1) = surfaceB u interesection domain
+  v0 - [in]
+  v1 - [in] (v0,v1) = surfaceB v interesection domain
+Returns:
+  << TODO: Add return codes here >>
+See Also:
+  ON_Curve::IntersectSurface
+  ON_SetCurveCurveIntersectionDir
+*/
+ON_DECL
+bool ON_SetCurveSurfaceIntersectionDir(
+            int xcount,
+            ON_X_EVENT* xevent,
+            double t0,
+            double t1,
+            double u0,
+            double u1,
+            double v0,
+            double v1
+            );
+
+// The ON_SSX_EVENT class is used to report surface-surface
+// intersection events.
+class ON_CLASS ON_SSX_EVENT
+{
+  // NO VIRTUAL FUNCTIONS IN THIS CLASS
+public:
+  ON_SSX_EVENT();
+  ~ON_SSX_EVENT(); // deletes m_curveA, m_curveB, m_curve3d
+
+  void Dump(ON_TextLog& text_log) const;
+
+  /*
+  Description:
+    Check intersection event values to make sure they are valid.
+  Parameters:
+    text_log - [in] If not null and an error is found, then a description
+                    of the error is printed to text_log.
+    intersection_tolerance - [in] 
+         0.0 or value used in intersection calculation.
+    overlap_tolerance - [in] 
+         0.0 or value used in intersection calculation.
+    fitting_tolerance - [in] 
+         0.0 or value used in intersection calculation.
+    surfaceA - [in] 
+         NULL or surfaceA passed to intersection calculation.
+    surfaceA_domain0 - [in]
+         NULL or surfaceA "u" domain used in intersection calculation.
+    surfaceA_domain1 - [in]
+         NULL or surfaceA "v" domain used in intersection calculation.
+    surfaceB - [in]
+         NULL or surfaceB passed to intersection calculation.
+    surfaceB_domain0 - [in]
+         NULL or surfaceB "u" domain used in intersection calculation.
+    surfaceB_domain1 - [in]
+         NULL or surfaceB "v" domain used in intersection calculation.
+  Returns:
+    True if event is valid.
+  */
+  bool IsValid(
+          ON_TextLog* text_log,
+          double intersection_tolerance,
+          double overlap_tolerance,
+          double fitting_tolerance,
+          const class ON_Surface* surfaceA,
+          const class ON_Interval* surfaceA_domain0,
+          const class ON_Interval* surfaceA_domain1,
+          const class ON_Surface* surfaceB,
+          const class ON_Interval* surfaceB_domain0,
+          const class ON_Interval* surfaceB_domain1
+          ) const;
+
+  /*
+  Returns:
+    True if m_type is ssx_transverse_point or ssx_tangent_point.
+  See Also:
+    ON_SSX_EVENT::IsCurveEvent
+    ON_SSX_EVENT::IsTinyEvent
+  */
+  bool IsPointEvent() const;
+
+  /*
+  Returns:
+    True if m_type is ssx_transverse or ssx_tangent.
+  See Also:
+    ON_SSX_EVENT::IsPointEvent
+    ON_SSX_EVENT::IsTinyEvent
+  */
+  bool IsCurveEvent() const;
+
+  /*
+  Description:
+    This function can be used to detect intersection events
+    that are "nearly" points.
+  Parameters:
+    tiny_tolerance - [in]
+  Returns:
+    True if 
+    m_type is ssx_transverse_point or ssx_tangent_point,
+    or,
+    m_type is ssx_transverse, ssx_tangent or ssx_overlap
+    and length of the longest side of m_curve3d's
+    bounding box is <= tiny_tolerance.
+  See Also:
+    ON_SSX_EVENT::IsPointEvent
+    ON_SSX_EVENT::IsCurveEvent
+  */
+  bool IsTinyEvent(double tiny_tolerance) const;
+
+  /*
+  Returns:
+    True if m_type is ssx_tangent,  or ssx_tangent_point.
+  */
+  bool IsTangentEvent() const;
+
+  /*
+  Returns:
+    True if m_type is ssx_overlap.
+  */
+  bool IsOverlapEvent() const;
+
+  // This field is a scratch field for users.
+  // The constructor sets it to zero and the 
+  // intersectors never use it.
+  ON_U m_user;
+
+  enum TYPE
+  {
+    no_ssx_event         = 0,
+    ssx_transverse       = 1, // transverse surface-surface intersection curve
+    ssx_tangent          = 2, // tangent surface-surface intersection curve
+    ssx_overlap          = 3, // overlap surface-surface intersection curve
+    ssx_transverse_point = 4, // transverse surface-surface intersection point
+    ssx_tangent_point    = 5, // tangent surface-surface intersection point
+    ssx_32bit_enum       = 0xFFFFFFFF
+  };
+
+  TYPE m_type;
+
+  // If m_type = ssx_transverse, ssx_tangent, or ssx_overlap,
+  // then the intersection curves are returned here.  
+  // In all cases the 3 curves are compatibly oriented.
+  // For ssx_transverse events, the 3d curve direction
+  // agrees with SurfaceNormalB x SurfaceNormalA
+  // For ssx_tangent events, the orientation is random.
+  // For ssx_overlap events, the overlap is to the left of
+  // m_curveA.  These curves are deleted by ~ON_SSX_EVENT().
+  // If you want to harvest a curve for long term use, set 
+  // the pointer to NULL.
+  ON_Curve* m_curveA;  // 2d surface A parameter space curve
+  ON_Curve* m_curveB;  // 2d surface B parameter space curve
+  ON_Curve* m_curve3d; // 3d surface B parameter space curve
+
+  // If m_type = ssx_transverse_point or ssx_tangent_point,
+  // the the points are returned here
+  ON_3dPoint m_pointA;  // 2d surfaceA parameter space point with z = 0
+  ON_3dPoint m_pointB;  // 2d surfaceB parameter space point with z = 0
+  ON_3dPoint m_point3d; // 3d intersection point
+};
+
+#endif
